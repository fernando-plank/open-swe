import "@langchain/langgraph/zod";
import { z } from "zod";
import {
  LangGraphRunnableConfig,
  Messages,
  messagesStateReducer,
  MessagesZodState,
} from "@langchain/langgraph/web";
import { MODEL_OPTIONS, MODEL_OPTIONS_NO_THINKING } from "./models.js";
import { ConfigurableFieldUIMetadata } from "../configurable-metadata.js";
import {
  uiMessageReducer,
  type UIMessage,
  type RemoveUIMessage,
} from "@langchain/langgraph-sdk/react-ui";
import {
  GITHUB_INSTALLATION_NAME,
  GITHUB_INSTALLATION_TOKEN_COOKIE,
  GITHUB_TOKEN_COOKIE,
  GITHUB_USER_ID_HEADER,
  GITHUB_USER_LOGIN_HEADER,
  GITHUB_PAT,
  DEFAULT_MCP_SERVERS,
  GITHUB_INSTALLATION_ID,
} from "../constants.js";
import { withLangGraph } from "@langchain/langgraph/zod";
import { BaseMessage } from "@langchain/core/messages";
import { tokenDataReducer } from "../caching.js";

export interface CacheMetrics {
  cacheCreationInputTokens: number;
  cacheReadInputTokens: number;
  inputTokens: number;
  outputTokens: number;
}

export interface ModelTokenData extends CacheMetrics {
  /**
   * The model name that generated this token usage data
   * e.g., "anthropic:claude-sonnet-4-0", "openai:gpt-4.1-mini"
   */
  model: string;
}

export type PlanItem = {
  /**
   * The index of the plan item. This is the order in which
   * it should be executed.
   */
  index: number;
  /**
   * The actual task to perform.
   */
  plan: string;
  /**
   * Whether or not the plan item has been completed.
   */
  completed: boolean;
  /**
   * A summary of the completed task.
   */
  summary?: string;
};

export type PlanRevision = {
  /**
   * The revision index of the plan.
   * This is used to track edits made to the plan by the agent or user
   */
  revisionIndex: number;
  /**
   * The plans for this task & revision.
   */
  plans: PlanItem[];
  /**
   * Timestamp when this revision was created
   */
  createdAt: number;
  /**
   * Who created this revision (agent or user)
   */
  createdBy: "agent" | "user";
};

export type Task = {
  /**
   * Unique identifier for the task
   */
  id: string;
  /**
   * The index of the user's task in chronological order
   */
  taskIndex: number;
  /**
   * The original user request that created this task
   */
  request: string;
  /**
   * The title of the task. Generated by the LLM.
   */
  title: string;
  /**
   * When the task was created
   */
  createdAt: number;
  /**
   * Whether the task is completed
   */
  completed: boolean;
  /**
   * When the task was completed
   */
  completedAt?: number;
};

export const GraphAnnotation = MessagesZodState.extend({
  /**
   * A list of all tasks for this run.
   */
  tasks: withLangGraph(z.custom<Task[]>(), {
    reducer: (_state, update) => update,
  }),
  /**
   * A list of all plan revisions for this run.
   */
  planRevisions: withLangGraph(z.custom<PlanRevision[]>(), {
    reducer: (_state, update) => update,
  }),
  /**
   * A list of all token usage data for this run.
   */
  modelTokenData: withLangGraph(z.custom<ModelTokenData[]>(), {
    reducer: tokenDataReducer,
  }),
  /**
   * The initial prompt from the user.
   */
  initialPrompt: withLangGraph(z.string(), {
    reducer: (_state, update) => update,
  }),
  /**
   * The problem statement for the task.
   */
  problemStatement: withLangGraph(z.string(), {
    reducer: (_state, update) => update,
  }),
  /**
   * Messages to be displayed in the UI.
   */
  uiMessages: withLangGraph(
    z.custom<Messages>(),
    {
      reducer: (state, update) =>
        uiMessageReducer(state, update),
    },
  ),
  /**
   * The last entity that updated the graph state.
   */
  lastUpdatedBy: withLangGraph(z.string().optional(), {
    reducer: (_state, update) => update,
  }),
  /**
   * The ID of the current task being worked on.
   */
  currentTaskId: withLangGraph(z.string().optional(), {
    reducer: (_state, update) => update,
  }),
  /**
   * The target repository for the agent to work on.
   */
  targetRepository: withLangGraph(z.string().optional(), {
    reducer: (_state, update) => update,
  }),
  /**
   * The URL of the pull request created by the agent.
   */
  pullRequestUrl: withLangGraph(z.string().optional(), {
    reducer: (_state, update) => update,
  }),
  /**
   * The current working directory of the agent. All shell commands will be executed here.
   */
  workingDirectory: withLangGraph(z.string().optional(), {
    reducer: (_state, update) => update,
  }),
  /**
   * The ID of the sandbox session.
   */
  sandboxSessionId: withLangGraph(z.string().optional(), {
    reducer: (_state, update) => update,
  }),
  /**
   * A tree representation of the codebase.
   */
  codebaseTree: withLangGraph(z.string().optional(), {
    reducer: (_state, update) => update,
  }),
  /**
   * Whether or not the dependencies have been installed.
   */
  dependenciesInstalled: withLangGraph(z.boolean().optional(), {
    reducer: (_state, update) => update,
  }),
});

export type GraphState = z.infer<typeof GraphAnnotation>;
export type GraphUpdate = Partial<GraphState>;

export const GraphConfigurationMetadata: Record<
  string,
  ConfigurableFieldUIMetadata
> = {
  plannerModel: {
    label: "Planner Model",
    description: "The model used to generate the plan.",
    options: MODEL_OPTIONS,
    type: "dropdown",
    default: "anthropic:claude-3.5-sonnet-20240620",
  },
  programmerModel: {
    label: "Programmer Model",
    description: "The model used to write the code.",
    options: MODEL_OPTIONS,
    type: "dropdown",
    default: "anthropic:claude-3.5-sonnet-20240620",
  },
  reviewerModel: {
    label: "Reviewer Model",
    description: "The model used to review the code.",
    options: MODEL_OPTIONS_NO_THINKING,
    type: "dropdown",
    default: "anthropic:claude-3-haiku-20240307",
  },
  notetakerModel: {
    label: "Notetaker Model",
    description: "The model used to take notes.",
    options: MODEL_OPTIONS,
    type: "dropdown",
    default: "anthropic:claude-3.5-sonnet-20240620",
  },
  [GITHUB_TOKEN_COOKIE]: {
    label: "GitHub Token",
    description: "Your GitHub token.",
    type: "string",
    default: "",
  },
  [GITHUB_INSTALLATION_TOKEN_COOKIE]: {
    label: "GitHub Installation Token",
    description: "The installation token for the GitHub app.",
    type: "string",
    default: "",
  },
  [GITHUB_USER_ID_HEADER]: {
    label: "GitHub User ID",
    description: "Your GitHub user ID.",
    type: "string",
    default: "",
  },
  [GITHUB_USER_LOGIN_HEADER]: {
    label: "GitHub User Login",
    description: "Your GitHub user login.",
    type: "string",
    default: "",
  },
  [GITHUB_INSTALLATION_NAME]: {
    label: "GitHub Installation Name",
    description: "The name of the GitHub app installation.",
    type: "string",
    default: "",
  },
  [GITHUB_INSTALLATION_ID]: {
    label: "GitHub Installation ID",
    description: "The ID of the GitHub app installation.",
    type: "string",
    default: "",
  },
  [GITHUB_PAT]: {
    label: "GitHub Personal Access Token",
    description: "Your GitHub Personal Access Token.",
    type: "string",
    default: "",
  },
  mcpServers: {
    label: "MCP Servers",
    description: "Custom MCP servers configuration as JSON string.",
    type: "string",
    default: JSON.stringify(DEFAULT_MCP_SERVERS, null, 2),
  },
  maxReviewCount: {
    label: "Max Review Count",
    description: "The maximum number of times the reviewer can be executed.",
    type: "number",
    default: 5,
  },
};

export const GraphConfiguration = z.object({
  /**
   * The model used to generate the plan.
   */
  plannerModel: withLangGraph(z.string().optional(), {
    metadata: GraphConfigurationMetadata.plannerModel,
  }),
  /**
   * The model used to write the code.
   */
  programmerModel: withLangGraph(z.string().optional(), {
    metadata: GraphConfigurationMetadata.programmerModel,
  }),
  /**
   * The model used to review the code.
   */
  reviewerModel: withLangGraph(z.string().optional(), {
    metadata: GraphConfigurationMetadata.reviewerModel,
  }),
  /**
   * The model used to take notes.
   */
  notetakerModel: withLangGraph(z.string().optional(), {
    metadata: GraphConfigurationMetadata.notetakerModel,
  }),
  /**
   * The user's GitHub token. This is used to make requests to the GitHub API on behalf of the user.
   * It is also used to make requests to get information about the user.
   */
  [GITHUB_TOKEN_COOKIE]: withLangGraph(z.string().optional(), {
    metadata: GraphConfigurationMetadata[GITHUB_TOKEN_COOKIE],
  }),
  /**
   * The installation token from the GitHub app. This token allows us to take actions
   * on the repos the user has granted us access to, but on behalf of the app, not the user.
   */
  [GITHUB_INSTALLATION_TOKEN_COOKIE]: withLangGraph(z.string().optional(), {
    metadata: GraphConfigurationMetadata[GITHUB_INSTALLATION_TOKEN_COOKIE],
  }),
  /**
   * The user's GitHub ID. Required when creating runs triggered by a bot (e.g. GitHub issue)
   */
  [GITHUB_USER_ID_HEADER]: withLangGraph(z.string().optional(), {
    metadata: GraphConfigurationMetadata[GITHUB_USER_ID_HEADER],
  }),
  /**
   * The user's GitHub login. Required when creating runs triggered by a bot (e.g. GitHub issue)
   */
  [GITHUB_USER_LOGIN_HEADER]: withLangGraph(z.string().optional(), {
    metadata: GraphConfigurationMetadata[GITHUB_USER_LOGIN_HEADER],
  }),
  /**
   * The installation name of the GitHub app. Required when creating runs triggered by a bot (e.g. GitHub issue)
   */
  [GITHUB_INSTALLATION_NAME]: withLangGraph(z.string().optional(), {
    metadata: GraphConfigurationMetadata[GITHUB_INSTALLATION_NAME],
  }),
  /**
   * The installation ID of the GitHub app the user is using to create the run.
   */
  [GITHUB_INSTALLATION_ID]: withLangGraph(z.string().optional(), {
    metadata: GraphConfigurationMetadata[GITHUB_INSTALLATION_ID],
  }),
  /**
   * GitHub Personal Access Token. Used for simpler authentication in environments like evals
   * where GitHub App installation tokens are not available or needed.
   */
  [GITHUB_PAT]: withLangGraph(z.string().optional(), {
    metadata: GraphConfigurationMetadata[GITHUB_PAT],
  }),
  /**
   * Custom MCP servers configuration as JSON string. Merges with default servers.
   * @default Default LangGraph docs MCP server
   */
  mcpServers: withLangGraph(z.string().optional(), {
    metadata: GraphConfigurationMetadata.mcpServers,
  }),
  /**
   * The maxium number of times the reviewer subgraph can be executed.
   */
  maxReviewCount: withLangGraph(z.number().optional(), {
    metadata: GraphConfigurationMetadata.maxReviewCount,
  }),
});

export type GraphConfig = LangGraphRunnableConfig<
  z.infer<typeof GraphConfiguration> & {
    thread_id: string;
    run_id: string;
    assistant_id: string;
  }
>;

export interface AgentSession {
  threadId: string;
  runId: string;
}
